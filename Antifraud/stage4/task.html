<html>
<h2>Description</h2>
<p>
    An enterprise anti-fraud system has hundreds of merchant users who take advantage of the system by only checking
    validity of the transactions.
    Such kind of users do not need to modify and see list of stolen cards, suspicious IP addresses and even other users.
    On the other hand, there are limited number of support users who are responsible for reporting stolen cards/IPs and
    excluding them from blacklist.
    This type of users do not need to have access to the user management.
    Finally, there are a few users who are completely trusted and are allowed to access and modify more sensitive data.
</p>
<h2>Theory</h2>
<p>
<h3> Authentication and Authorization</h3>
    In this stage authentication and authorization is added to the antifraud-system.
    Authentication refers to the confirmation of user identity by checking their PIN, password, fingerprint, or face.
    On the other hand, authentication refers to the confirmation of an already authenticated user for an specific
    activity in the system.

<h3>Encoding the Password</h3>
    Here authentication is done through a <code>password</code> field that should be sent with the username in each
    request.
    The received password is compared with the user password in order to confirm user identity.
    It is not good practice to maintain password inside the system as plain text.
    Then a special kind of function is applied to the passwords before saving them in order to make them unusable for
    ... attackers who managed to see the user database table.
    A hash function performs a set of operations on the input message which is very hard to be reversed. MD5, and SHA-1
    are some examples of the hash functions.
    Luckily Spring Security framework provides a strong encryption <B>BCrypt</B> password encoder that is stronger than the
    above hashing algorithms.

<h3> Basic Authentication Header</h3>
    Among many ways of user authentication in HTTP
    (https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization), the BASIC authentication is simplest and
    most famous one.
    In the basic authentication, a header key <i>Authentication</i> is added to the HTTP request header.
    The value of the key is as follows:
    <code>"Basic: encode(user+password)</code>


<h2>Objectives</h2>

<ol>
    <li>Enrich the User model by adding field <code>password</code></li>
    <li>Passwords are immediately encoded with <B>BCrypt</B> of the Spring Security</li>
    <li>Add an endpoint to user controller for changing password</li>
    <li>Basic user can only do the following:
        <ul>
            <li>Change her/his password</li>
            <li>Ask for the validity of a transaction</li>
        </ul>
    </li>
    <li>A support users can do whatever a basic user can do. In addition, the following are allowed for a support user
        <ul>
            <li>Stolen Card Management, i.e. get list, add, remove</li>
            <li>Suspicious IP Management, i.e. get list, add, remove</li>
        </ul>
    </li>
    <li>Updating/Adding/Removing users, are only done by the admin users.
        In the other world admin users have access to every endpoint of the system.
    </li>
    <li>Add a preconfigured admin user admin with password admin should be added by default with username=admin,
        password=admin, and name=admin
    </li>
</ol>

<h2>Important Implementation Notes:</h2>
<ol>
    <li>
        It is recommended that method security annotation of spring security
        (https://www.baeldung.com/spring-security-method-security,
        https://docs.spring.io/spring-security/site/docs/3.0.x/reference/el-access.html) is used.
        <code>
            @PutMapping("/{username}")
            @PreAuthorize("hasRole('ROLE_ADMIN') or #username == authentication.principal.username")
            public ResponseEntity User changePassword(@PathVariable String username, @RequestBody String password) {
            User changedPasswordUser = userService.changePassword(username, password);
            return ResponseEntity.ok(changedPasswordUser);
            }
        </code>
    </li>
    <li>It is recommended that the csrf(reference needed) is disabled in order to ease testing. Althogh it is not
        recommended in real world project, here we suggest a configuration like
        <code>
            @EnableWebSecurity
            @Configuration
            @EnableGlobalMethodSecurity(
            prePostEnabled = true,
            securedEnabled = true,
            jsr250Enabled = true
            )
            public class SecurityConfiguration extends WebSecurityConfigurerAdapter {

            @Bean
            public PasswordEncoder passwordEncoder() {
            return new BCryptPasswordEncoder();
            }

            @Override
            protected void configure(HttpSecurity http) throws Exception {
            http.authorizeRequests().anyRequest().authenticated()
            .and().httpBasic()
            .and().logout()
            .and().csrf().disable();
            }
            }
        </code>
    </li>
</ol>
<h2>Examples</h2>


</html>